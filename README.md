# java-was-2023

소프티어 부트캠프 WAS 애플리케이션

# step-1
## 구현 내용
- Java의 thread와 Concurrent package에 대해서 학습하고 정리/기록했다.
- Http 요청이 발생했을 때 이를 로그로 출력하는 기능을 구현했다.
- index.html에 대한 Http 요청이 발생했을 때 이를 http 응답에 담아 보내는 기능을 구현했다.
- Http 요청 메세지와 Http 응답 메세지를 나타내는 VO 클래스를 구현했다.
- Input/OutputStream과 Http 메세지를 파싱하는 기능을 구현했다.
- 파싱과 관련된 테스트 코드를 구현했다.

## 고민 사항
- concurrent package를 이용하되, 어떤 스레드풀 객체를 이용할 것인지에 대해서 고민했다. 작업의 발생이 일정하고, 처리하는 작업의 로드도 작고 일정하기 때문에 newFixedThreadPool() 메소드를 이용했다.
- HttpReqeust, HttpResponse, URI 클래스를 VO로 만드는 대안에 대해서 고민했다. 발생하는 요청 정보를 담고, (HttpRequest) 그에 대한 응답 정보를 담는 (HttpResponse) 역할을 하기 때문에 생성 이후에는 변경을 제한하고 의미를 더할 필요가 있다고 생각했다.
- InputStream, HttpResponse를 파싱하는 로직을 어디서에 구현해야할 지에 대해서 많은 고민을 했다. (1) Parser 클래스를 만들어 inputStream을 입력받아 HttpRequest를 반환하는 메소드와 HttpResponse를 입력받아 Outputstream을 반환하는 메소드를 모두 갖고 있게 하는 방법과, (2) HttpResponse와 HttpRequest 클래스에서 파싱하는 로직을 모두 갖게 방법 -> 두 가지의 대안을 생각했다. <br>
  전자를 선택했다. 후자의 경우 필드에 직접 접근하는 등의 이유로 코드와 로직이 간결해지는 장점이 있지만, 두 VO 클래스의 본질적인 역할을 생각했을 때 파싱 로직을 갖고 있지 않는 것이 맞다고 판단했다. 이에 더해서 Parser를 분리하면 RequestHandler와 메세지 객체 사이의 결합도가 낮아지고, 수정에 유리한 구조가 될 것이라고 생각했다.

## 기타
- 정적인 템플릿 요청에 대해서, 이걸 찾아서 바이트로 넘겨주는 역할을 분리해야할 것 같다.
- Http method, query에 따라서 처리하는 메소드를 선언해서, 이를 요청과 매핑하는 기능의 구조를 생각해야할 것 같다.
- 예외 상황에 따라 올바른 상태코드를 넘기는 기능 구현에 대해 생각해봐야할 것 같다.

--- 

# step-2
## 구현 내용
- 컴파일 시점에 Controller method들을 저장하고, Http 요청을 받으면 매핑된 메소드에게 처리하도록 하는 기능 구현
- User 객체 데이터베이스 저장 기능 구현
- GET 회원 가입 기능 구현
- 올바르지 않은 요청에 대한 예외 처리, Http 응답 기능 구현
- 엔드포인트를 제외한 모든 로직 단위 테스트 구현 

## 고민 사항
- 역할을 잘 나타내기 위한 클래스명에 대한 고민을 했다. webserver 패키지 내의 대부분의 클래스가 http 요청을 handling하는 역할을 한다고 생각했다. 의미와 기능을 더 세분화해서 이것을 나타낼 수 있는 이름으로 나누었다.
- 멀티 스레드가 동시에 접근할 수 있는 메소드들을 static으로 관리하는 것에 대해서 고민했다. Controller, HttpRequestRouter를 싱글톤으로 관리하는 방식이 또 다른 대안이었다. static하게 관리할 경우 객체를 생성할 필요가 없고 동시성 관련 이슈가 없지만, 메모리 낭비가 발생하기 때문에 싱글톤 패턴을 이용하는 방식에 비해서 비효율적이라고 판단해서 내부 클래스를 통해 인스턴스 생성 시점에 싱글톤 객체가 생성되는 방식으로 구현했다.
- Controller를 일반적으로 사용할 수 있게 하는 방법에 대해서 고민했다. 지금의 방식은 HttpRequestRouter가 static block에서 Controller 클래스에 직접적으로 의존하는데, 실제로 모든 애플리케이션에 유연하게 적용되기 위해서는 특정한 클래스에 직접 의존하지 않고 어노테이션이나 상속/구현을 통해서 대상 메소드들을 탐색하는 방식의 처리가 필요하다고 생각한다. 클래스 로더나 파일 탐색과 관련된 추가적인 공부 후에 적용해볼 것이다.
- 예외를 받아서 처리하는 곳, 이를 반영해서 응답 헤더에 상태 코드를 반영하는 곳을 어디로 결정할 지 고민을 많이 했다. 결과적으로 지금은 HttpResponse를 만들고 관리하는 곳에서 예외를 처리하고, 상태 코드를 반영하도록 구현했다. 더 앞 단인 RequestHandler에서 받은 HttpResponse를 수정함으로써 한 번에 처리할 수도 있었지만, HttpResponse가 각 계층을 거쳐 소켓으로 빠져나갈 때까지 그 값이 수정되지 않았으면 했다. VO로 만듦으로써 안정적이고 예측 가능하게 관리하고 싶었다. 반면에 전자의 방식은 예외를 통합적으로 관리하고 코드가 깔끔해진다는 장점이 있었다. 후자가 확실하게 더 좋은 방식이라고 말할 수 없고 아직도 고민이 되지만, 얻는 이점이 더 크다고 판단했다.

---

# step-3
## 구현 내용
- 리다이렉트 기능 구현
- 요청 URI의 MIME 타입에 따른 처리 로직 구현
- 영속 계층 동시성 관련 버그 수정
- 어노테이션을 이용한 파라미터 검증 로직 구현

## 고민 사항
- 클래스 내부 필드가 Optional 타입을 갖는 것에 대해서 고민했다. URI의 쿼리와 확장자는 존재하지 않을 수 있는데 null을 사용하고 싶지 않기 때문이었다. 내가 판단한 Optional 사용했을 때의 장점은 존재하지 않을 수 있다는 의미를 확실하게 보여줄 수 있다는 점과, NPE 리스크가 없다는 점, 추가적인 처리가 필요 없다는 점이다. 반면에 사용했을 때 추가적인 오버헤드가 발생한다는 단점도 알게 되었다. 이 둘 사이를 잘 저울질해야할 것 같은데, 아직 결정하지 못했다.
- WAS의 역할이 무엇이고 이것을 달성하기 위해서 역할을 어떻게 분리해야할 지 고민했다. Application은 회원 관리, 게시판 관리를 포함하고 있어야 하며, 이 과정에서 WAS가 제공하는 방식에 의존하는 식이어야한다고 생각했다. 즉, 애플리케이션의 형태가 변하더라도 웹 서버는 일반적으로 적용될 수 있어야 한다는 것이다. 이 생각을 기준으로 기존에는 Application이 가지고 있었던 로직을 일부 분리했다.
  ex)  query parameter의 유효성 검증을 Application에 속하는 User 도메인이 가지고 있었고, 이를 해결하기 위해서 입력이 필수적인 매개변수를 어노테이션을 이용해서 확인하는 로직을 추가했다. 

## 기타
- 응답 메세지의 헤더와 바디를 채우는 로직이 여러 개 존재하면서, 일관성 없이 작성된 것 같다. (정적인 리소스에 대한 요청과, Controller를 통한 요청 등) 이 부분을 분리해내고 추상화할 필요가 있을 것 같은데 아직 해결하지 못했다.

---

# step-4
## 구현 내용
- 필드 유무의 유동성을 반영하기 위해서 HttpRequest, HttpResponse 객체를 Builder 패턴으로 생성하도록 구현
- 컨텐츠 타입에 따라서 요청 바디를 파싱하는 클래스 구현 
- 요청 바디의 파라미터와 URI 경로의 파라미터를 구분해서 검증하고 controller에게 매핑하는 기능 구현
- redirect 기능 구현
- POST 요청에 대한 처리, 회원 가입 기능 구현

## 고민 사항
- Controller의 인자에서 URI의 쿼리 스트링과, BODY의 파라미터에 있는 값을 어떻게 구분하고 검증할 것인지 고민했다. 어노테이션으로 파라미터의 특성을 구분하고, HttpRequestRouter에서 입력받은 매개변수들을 Body의 매개변수와 Path의 매개변수로 구분한 뒤에 각각 검증한 후 매핑하는 로직을 구현했다. 다만 이 둘을 나타내는 변수의 이름을 더 직관적이고 확실히 구분하도록 수정할 필요가 있을 것 같다.
- content-type에 따라서 요청 바디를 파싱하는 로직을 달리 하는 방법에 대해서 고민했다. HttpRequestParser 입장에서 Content-type을 신경쓰지 않게, Content-type이 변경되더라도 일관적으로 처리할 수 있도록 구현해야한다고 생각했기 때문이다. 바디를 파싱하는 로직을 추상화해서 RequestBodyParser로 선언하고, content-type 별로 이를 구현하도록 했다. 그리고 이 객체들을 관리해서 실행하는 Manager 클래스를 만들어 HttpRequestParser가 의존하게 했다.

---

# step-5
## 구현 내용
- 로그인 기능 구현
   - 쿠키, 세션 클래스를 비롯한 관리 기능 구현
- HttpHeader를 클래스로 선언하고 Cookie를 리스트로 관리하도록 구현
- 헤더 파싱 로직 수정
- 리팩토링에 따라 테스트 코드 수정 및 추가된 기능 테스트 코드 구현

## 고민 사항
- 세션, 쿠키의 생성과 관리, 확인을 어떤 클래스에서 담당해야할 지에 대해서 고민했다. 이것을 생성하고 관리하는 것이 웹 서버의 역할일 지, 전적으로 애플리케이션에서 담당하게 해야할 지를 결정하지 못했다. 내 프레임워크가 제공하는 기능과 목적은 애플리케이션에 Http 요청과 응답을 연결해주는 것이라고 생각했는데, 이런 관점에서 봤을 때 클라이언트가 원하는대로 생성하고 확인할 수 있되, 이를 관리하는 역할만을 서버가 해야할 것이라고 판단했다. 물론 프레임워크의 사용성의 측면에서 어느 정도의 자유도를 주는 것이 좋을지는 정답이 없는 문제라고 생각한다.
- 지금 내 프로그램에서 Controller의 역할에 대해서 고민했다. 지금은 비즈니스 로직을 처리하고, (쿠키와 세션 관련 로직 포함) HttpResponse 객체를 만들어서 반환하는 모든 기능을 맡고 있는데 역할이 비대하다는 생각도 조금 들었고, 일반적인 "Controller"라는 단어가 갖는 의미와 다르다는 생각도 든다. MVC 패턴을 참조해서 View 관련 역할을 분리하거나, 그렇지 않는다면 클래스의 이름을 제 역할을 더 잘 나타낼 수 있도록 바꿀 필요가 있는 것 같다.

## 기타
- 요청 헤더에 포함된 쿠키를 관리하는 로직과, 이것을 어디에 포함시킬 지에 대해서 생각해봐야겠다.

---

# step-6
## 구현 내용
- html의 동적 렌더링 기능 구현
   - User 정보를 기반으로 HTML을 조작해서 Renderer 클래스, path별 Renderer를 관리하는 HTM<RendererManager 클래스 구현
   - 요청에 포함된 쿠키로부터 세션 객체를 얻어오고, 이를 검증하는 로직 구현
- 패키지 구조 수정, 클래스 리네임, 메소드 추출 등 리팩토링
- static 메소드만을 갖고 있었던 클래스들을 싱글톤으로 관리하도록 리팩토링

## 고민 사항
  static 메소드만을 갖는 클래스들을 변경해서 싱글톤 인스턴스로 관리하도록 하는 방법에 대해서 고민했다. 원래는 이 두 가지 방법을 동시에 사용했었는데, 두 방법의 장단점에 대해서 제대로 이해하고 결정하지 않았었다. Http 메세지를 파싱하는 클래스나, HttpBody를 컨텐츠 타입에 따라서 BodyParser를 호출해주는 클래스 등은 유틸 클래스로서의 특징을 많이 가진다고 생각해서 static 메소드들을 갖는 것이 적합하다는 생각도 들었고, 반면에 싱글톤으로 관리하는 것이 확장이 필요하게 되었을 때 유연성의 측면에서는 훨씬 유리하다는 생각도 들었다. 또한 이 클래스들 중에서는 globally accessed되는 경우도 없을 것이라고 판단해서, 지금은 싱글톤 인스턴스로 관리하도록 변경했다. <br>
  HTML을 동적으로 렌더링하는 역할을 어디에 부여해야할 지 많이 고민했다. RequestProcessor가 path 별로 필요한 매개변수를 받아 모든 비즈니스 로직을 처리하고 있었기 때문에 출력을 담당하는 부분을 새롭게 추가하기가 어려웠다. 결국 HTML의 동적 처리를 맡는 HTMLRenderer의 각 구현체를 전략 패턴으로 RequestProcessor가 이용하도록 구현했다. 
